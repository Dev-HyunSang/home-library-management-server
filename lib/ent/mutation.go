// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/dev-hyunsang/home-library/lib/ent/adminapikey"
	"github.com/dev-hyunsang/home-library/lib/ent/book"
	"github.com/dev-hyunsang/home-library/lib/ent/bookmark"
	"github.com/dev-hyunsang/home-library/lib/ent/predicate"
	"github.com/dev-hyunsang/home-library/lib/ent/readingreminder"
	"github.com/dev-hyunsang/home-library/lib/ent/review"
	"github.com/dev-hyunsang/home-library/lib/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdminAPIKey     = "AdminAPIKey"
	TypeBook            = "Book"
	TypeBookmark        = "Bookmark"
	TypeReadingReminder = "ReadingReminder"
	TypeReview          = "Review"
	TypeUser            = "User"
)

// AdminAPIKeyMutation represents an operation that mutates the AdminAPIKey nodes in the graph.
type AdminAPIKeyMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	key_hash      *string
	key_prefix    *string
	is_active     *bool
	last_used_at  *time.Time
	expires_at    *time.Time
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AdminAPIKey, error)
	predicates    []predicate.AdminAPIKey
}

var _ ent.Mutation = (*AdminAPIKeyMutation)(nil)

// adminapikeyOption allows management of the mutation configuration using functional options.
type adminapikeyOption func(*AdminAPIKeyMutation)

// newAdminAPIKeyMutation creates new mutation for the AdminAPIKey entity.
func newAdminAPIKeyMutation(c config, op Op, opts ...adminapikeyOption) *AdminAPIKeyMutation {
	m := &AdminAPIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminAPIKeyID sets the ID field of the mutation.
func withAdminAPIKeyID(id uuid.UUID) adminapikeyOption {
	return func(m *AdminAPIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminAPIKey
		)
		m.oldValue = func(ctx context.Context) (*AdminAPIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminAPIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminAPIKey sets the old AdminAPIKey of the mutation.
func withAdminAPIKey(node *AdminAPIKey) adminapikeyOption {
	return func(m *AdminAPIKeyMutation) {
		m.oldValue = func(context.Context) (*AdminAPIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminAPIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminAPIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminAPIKey entities.
func (m *AdminAPIKeyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminAPIKeyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminAPIKeyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminAPIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AdminAPIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AdminAPIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AdminAPIKey entity.
// If the AdminAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminAPIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AdminAPIKeyMutation) ResetName() {
	m.name = nil
}

// SetKeyHash sets the "key_hash" field.
func (m *AdminAPIKeyMutation) SetKeyHash(s string) {
	m.key_hash = &s
}

// KeyHash returns the value of the "key_hash" field in the mutation.
func (m *AdminAPIKeyMutation) KeyHash() (r string, exists bool) {
	v := m.key_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyHash returns the old "key_hash" field's value of the AdminAPIKey entity.
// If the AdminAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminAPIKeyMutation) OldKeyHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyHash: %w", err)
	}
	return oldValue.KeyHash, nil
}

// ResetKeyHash resets all changes to the "key_hash" field.
func (m *AdminAPIKeyMutation) ResetKeyHash() {
	m.key_hash = nil
}

// SetKeyPrefix sets the "key_prefix" field.
func (m *AdminAPIKeyMutation) SetKeyPrefix(s string) {
	m.key_prefix = &s
}

// KeyPrefix returns the value of the "key_prefix" field in the mutation.
func (m *AdminAPIKeyMutation) KeyPrefix() (r string, exists bool) {
	v := m.key_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPrefix returns the old "key_prefix" field's value of the AdminAPIKey entity.
// If the AdminAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminAPIKeyMutation) OldKeyPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPrefix: %w", err)
	}
	return oldValue.KeyPrefix, nil
}

// ResetKeyPrefix resets all changes to the "key_prefix" field.
func (m *AdminAPIKeyMutation) ResetKeyPrefix() {
	m.key_prefix = nil
}

// SetIsActive sets the "is_active" field.
func (m *AdminAPIKeyMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *AdminAPIKeyMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the AdminAPIKey entity.
// If the AdminAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminAPIKeyMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *AdminAPIKeyMutation) ResetIsActive() {
	m.is_active = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *AdminAPIKeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *AdminAPIKeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the AdminAPIKey entity.
// If the AdminAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminAPIKeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *AdminAPIKeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[adminapikey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *AdminAPIKeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[adminapikey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *AdminAPIKeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, adminapikey.FieldLastUsedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *AdminAPIKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AdminAPIKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AdminAPIKey entity.
// If the AdminAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminAPIKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *AdminAPIKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[adminapikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *AdminAPIKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[adminapikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AdminAPIKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, adminapikey.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminAPIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminAPIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminAPIKey entity.
// If the AdminAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminAPIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminAPIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminAPIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminAPIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminAPIKey entity.
// If the AdminAPIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminAPIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminAPIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the AdminAPIKeyMutation builder.
func (m *AdminAPIKeyMutation) Where(ps ...predicate.AdminAPIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminAPIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminAPIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminAPIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminAPIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminAPIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminAPIKey).
func (m *AdminAPIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminAPIKeyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, adminapikey.FieldName)
	}
	if m.key_hash != nil {
		fields = append(fields, adminapikey.FieldKeyHash)
	}
	if m.key_prefix != nil {
		fields = append(fields, adminapikey.FieldKeyPrefix)
	}
	if m.is_active != nil {
		fields = append(fields, adminapikey.FieldIsActive)
	}
	if m.last_used_at != nil {
		fields = append(fields, adminapikey.FieldLastUsedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, adminapikey.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, adminapikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adminapikey.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminAPIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminapikey.FieldName:
		return m.Name()
	case adminapikey.FieldKeyHash:
		return m.KeyHash()
	case adminapikey.FieldKeyPrefix:
		return m.KeyPrefix()
	case adminapikey.FieldIsActive:
		return m.IsActive()
	case adminapikey.FieldLastUsedAt:
		return m.LastUsedAt()
	case adminapikey.FieldExpiresAt:
		return m.ExpiresAt()
	case adminapikey.FieldCreatedAt:
		return m.CreatedAt()
	case adminapikey.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminAPIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminapikey.FieldName:
		return m.OldName(ctx)
	case adminapikey.FieldKeyHash:
		return m.OldKeyHash(ctx)
	case adminapikey.FieldKeyPrefix:
		return m.OldKeyPrefix(ctx)
	case adminapikey.FieldIsActive:
		return m.OldIsActive(ctx)
	case adminapikey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case adminapikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case adminapikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminapikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AdminAPIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminAPIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminapikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case adminapikey.FieldKeyHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyHash(v)
		return nil
	case adminapikey.FieldKeyPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPrefix(v)
		return nil
	case adminapikey.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case adminapikey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case adminapikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case adminapikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminapikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AdminAPIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminAPIKeyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminAPIKeyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminAPIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminAPIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminAPIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminapikey.FieldLastUsedAt) {
		fields = append(fields, adminapikey.FieldLastUsedAt)
	}
	if m.FieldCleared(adminapikey.FieldExpiresAt) {
		fields = append(fields, adminapikey.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminAPIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminAPIKeyMutation) ClearField(name string) error {
	switch name {
	case adminapikey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case adminapikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown AdminAPIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminAPIKeyMutation) ResetField(name string) error {
	switch name {
	case adminapikey.FieldName:
		m.ResetName()
		return nil
	case adminapikey.FieldKeyHash:
		m.ResetKeyHash()
		return nil
	case adminapikey.FieldKeyPrefix:
		m.ResetKeyPrefix()
		return nil
	case adminapikey.FieldIsActive:
		m.ResetIsActive()
		return nil
	case adminapikey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case adminapikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case adminapikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminapikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AdminAPIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminAPIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminAPIKeyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminAPIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminAPIKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminAPIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminAPIKeyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminAPIKeyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AdminAPIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminAPIKeyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AdminAPIKey edge %s", name)
}

// BookMutation represents an operation that mutates the Book nodes in the graph.
type BookMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	book_title       *string
	author           *string
	book_isbn        *string
	thumbnail_url    *string
	status           *int
	addstatus        *int
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	owner            *uuid.UUID
	clearedowner     bool
	reviews          map[uuid.UUID]struct{}
	removedreviews   map[uuid.UUID]struct{}
	clearedreviews   bool
	bookmarks        map[uuid.UUID]struct{}
	removedbookmarks map[uuid.UUID]struct{}
	clearedbookmarks bool
	done             bool
	oldValue         func(context.Context) (*Book, error)
	predicates       []predicate.Book
}

var _ ent.Mutation = (*BookMutation)(nil)

// bookOption allows management of the mutation configuration using functional options.
type bookOption func(*BookMutation)

// newBookMutation creates new mutation for the Book entity.
func newBookMutation(c config, op Op, opts ...bookOption) *BookMutation {
	m := &BookMutation{
		config:        c,
		op:            op,
		typ:           TypeBook,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookID sets the ID field of the mutation.
func withBookID(id uuid.UUID) bookOption {
	return func(m *BookMutation) {
		var (
			err   error
			once  sync.Once
			value *Book
		)
		m.oldValue = func(ctx context.Context) (*Book, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Book.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBook sets the old Book of the mutation.
func withBook(node *Book) bookOption {
	return func(m *BookMutation) {
		m.oldValue = func(context.Context) (*Book, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Book entities.
func (m *BookMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Book.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBookTitle sets the "book_title" field.
func (m *BookMutation) SetBookTitle(s string) {
	m.book_title = &s
}

// BookTitle returns the value of the "book_title" field in the mutation.
func (m *BookMutation) BookTitle() (r string, exists bool) {
	v := m.book_title
	if v == nil {
		return
	}
	return *v, true
}

// OldBookTitle returns the old "book_title" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldBookTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookTitle: %w", err)
	}
	return oldValue.BookTitle, nil
}

// ResetBookTitle resets all changes to the "book_title" field.
func (m *BookMutation) ResetBookTitle() {
	m.book_title = nil
}

// SetAuthor sets the "author" field.
func (m *BookMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *BookMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *BookMutation) ResetAuthor() {
	m.author = nil
}

// SetBookIsbn sets the "book_isbn" field.
func (m *BookMutation) SetBookIsbn(s string) {
	m.book_isbn = &s
}

// BookIsbn returns the value of the "book_isbn" field in the mutation.
func (m *BookMutation) BookIsbn() (r string, exists bool) {
	v := m.book_isbn
	if v == nil {
		return
	}
	return *v, true
}

// OldBookIsbn returns the old "book_isbn" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldBookIsbn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookIsbn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookIsbn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookIsbn: %w", err)
	}
	return oldValue.BookIsbn, nil
}

// ClearBookIsbn clears the value of the "book_isbn" field.
func (m *BookMutation) ClearBookIsbn() {
	m.book_isbn = nil
	m.clearedFields[book.FieldBookIsbn] = struct{}{}
}

// BookIsbnCleared returns if the "book_isbn" field was cleared in this mutation.
func (m *BookMutation) BookIsbnCleared() bool {
	_, ok := m.clearedFields[book.FieldBookIsbn]
	return ok
}

// ResetBookIsbn resets all changes to the "book_isbn" field.
func (m *BookMutation) ResetBookIsbn() {
	m.book_isbn = nil
	delete(m.clearedFields, book.FieldBookIsbn)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *BookMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *BookMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *BookMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[book.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *BookMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[book.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *BookMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, book.FieldThumbnailURL)
}

// SetStatus sets the "status" field.
func (m *BookMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *BookMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *BookMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *BookMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *BookMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BookMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BookMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BookMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Book entity.
// If the Book object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BookMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *BookMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *BookMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *BookMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *BookMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BookMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *BookMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *BookMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.reviews == nil {
		m.reviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *BookMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *BookMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *BookMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *BookMutation) RemovedReviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *BookMutation) ReviewsIDs() (ids []uuid.UUID) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *BookMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddBookmarkIDs adds the "bookmarks" edge to the Bookmark entity by ids.
func (m *BookMutation) AddBookmarkIDs(ids ...uuid.UUID) {
	if m.bookmarks == nil {
		m.bookmarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bookmarks[ids[i]] = struct{}{}
	}
}

// ClearBookmarks clears the "bookmarks" edge to the Bookmark entity.
func (m *BookMutation) ClearBookmarks() {
	m.clearedbookmarks = true
}

// BookmarksCleared reports if the "bookmarks" edge to the Bookmark entity was cleared.
func (m *BookMutation) BookmarksCleared() bool {
	return m.clearedbookmarks
}

// RemoveBookmarkIDs removes the "bookmarks" edge to the Bookmark entity by IDs.
func (m *BookMutation) RemoveBookmarkIDs(ids ...uuid.UUID) {
	if m.removedbookmarks == nil {
		m.removedbookmarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bookmarks, ids[i])
		m.removedbookmarks[ids[i]] = struct{}{}
	}
}

// RemovedBookmarks returns the removed IDs of the "bookmarks" edge to the Bookmark entity.
func (m *BookMutation) RemovedBookmarksIDs() (ids []uuid.UUID) {
	for id := range m.removedbookmarks {
		ids = append(ids, id)
	}
	return
}

// BookmarksIDs returns the "bookmarks" edge IDs in the mutation.
func (m *BookMutation) BookmarksIDs() (ids []uuid.UUID) {
	for id := range m.bookmarks {
		ids = append(ids, id)
	}
	return
}

// ResetBookmarks resets all changes to the "bookmarks" edge.
func (m *BookMutation) ResetBookmarks() {
	m.bookmarks = nil
	m.clearedbookmarks = false
	m.removedbookmarks = nil
}

// Where appends a list predicates to the BookMutation builder.
func (m *BookMutation) Where(ps ...predicate.Book) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Book, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Book).
func (m *BookMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.book_title != nil {
		fields = append(fields, book.FieldBookTitle)
	}
	if m.author != nil {
		fields = append(fields, book.FieldAuthor)
	}
	if m.book_isbn != nil {
		fields = append(fields, book.FieldBookIsbn)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, book.FieldThumbnailURL)
	}
	if m.status != nil {
		fields = append(fields, book.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, book.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, book.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case book.FieldBookTitle:
		return m.BookTitle()
	case book.FieldAuthor:
		return m.Author()
	case book.FieldBookIsbn:
		return m.BookIsbn()
	case book.FieldThumbnailURL:
		return m.ThumbnailURL()
	case book.FieldStatus:
		return m.Status()
	case book.FieldCreatedAt:
		return m.CreatedAt()
	case book.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case book.FieldBookTitle:
		return m.OldBookTitle(ctx)
	case book.FieldAuthor:
		return m.OldAuthor(ctx)
	case book.FieldBookIsbn:
		return m.OldBookIsbn(ctx)
	case book.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case book.FieldStatus:
		return m.OldStatus(ctx)
	case book.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case book.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Book field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) SetField(name string, value ent.Value) error {
	switch name {
	case book.FieldBookTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookTitle(v)
		return nil
	case book.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case book.FieldBookIsbn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookIsbn(v)
		return nil
	case book.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case book.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case book.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case book.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, book.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case book.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookMutation) AddField(name string, value ent.Value) error {
	switch name {
	case book.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Book numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(book.FieldBookIsbn) {
		fields = append(fields, book.FieldBookIsbn)
	}
	if m.FieldCleared(book.FieldThumbnailURL) {
		fields = append(fields, book.FieldThumbnailURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookMutation) ClearField(name string) error {
	switch name {
	case book.FieldBookIsbn:
		m.ClearBookIsbn()
		return nil
	case book.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	}
	return fmt.Errorf("unknown Book nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookMutation) ResetField(name string) error {
	switch name {
	case book.FieldBookTitle:
		m.ResetBookTitle()
		return nil
	case book.FieldAuthor:
		m.ResetAuthor()
		return nil
	case book.FieldBookIsbn:
		m.ResetBookIsbn()
		return nil
	case book.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case book.FieldStatus:
		m.ResetStatus()
		return nil
	case book.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case book.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Book field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, book.EdgeOwner)
	}
	if m.reviews != nil {
		edges = append(edges, book.EdgeReviews)
	}
	if m.bookmarks != nil {
		edges = append(edges, book.EdgeBookmarks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case book.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeBookmarks:
		ids := make([]ent.Value, 0, len(m.bookmarks))
		for id := range m.bookmarks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreviews != nil {
		edges = append(edges, book.EdgeReviews)
	}
	if m.removedbookmarks != nil {
		edges = append(edges, book.EdgeBookmarks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case book.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case book.EdgeBookmarks:
		ids := make([]ent.Value, 0, len(m.removedbookmarks))
		for id := range m.removedbookmarks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, book.EdgeOwner)
	}
	if m.clearedreviews {
		edges = append(edges, book.EdgeReviews)
	}
	if m.clearedbookmarks {
		edges = append(edges, book.EdgeBookmarks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookMutation) EdgeCleared(name string) bool {
	switch name {
	case book.EdgeOwner:
		return m.clearedowner
	case book.EdgeReviews:
		return m.clearedreviews
	case book.EdgeBookmarks:
		return m.clearedbookmarks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookMutation) ClearEdge(name string) error {
	switch name {
	case book.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Book unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookMutation) ResetEdge(name string) error {
	switch name {
	case book.EdgeOwner:
		m.ResetOwner()
		return nil
	case book.EdgeReviews:
		m.ResetReviews()
		return nil
	case book.EdgeBookmarks:
		m.ResetBookmarks()
		return nil
	}
	return fmt.Errorf("unknown Book edge %s", name)
}

// BookmarkMutation represents an operation that mutates the Bookmark nodes in the graph.
type BookmarkMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
	book          *uuid.UUID
	clearedbook   bool
	done          bool
	oldValue      func(context.Context) (*Bookmark, error)
	predicates    []predicate.Bookmark
}

var _ ent.Mutation = (*BookmarkMutation)(nil)

// bookmarkOption allows management of the mutation configuration using functional options.
type bookmarkOption func(*BookmarkMutation)

// newBookmarkMutation creates new mutation for the Bookmark entity.
func newBookmarkMutation(c config, op Op, opts ...bookmarkOption) *BookmarkMutation {
	m := &BookmarkMutation{
		config:        c,
		op:            op,
		typ:           TypeBookmark,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookmarkID sets the ID field of the mutation.
func withBookmarkID(id uuid.UUID) bookmarkOption {
	return func(m *BookmarkMutation) {
		var (
			err   error
			once  sync.Once
			value *Bookmark
		)
		m.oldValue = func(ctx context.Context) (*Bookmark, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bookmark.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBookmark sets the old Bookmark of the mutation.
func withBookmark(node *Bookmark) bookmarkOption {
	return func(m *BookmarkMutation) {
		m.oldValue = func(context.Context) (*Bookmark, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookmarkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookmarkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bookmark entities.
func (m *BookmarkMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookmarkMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookmarkMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bookmark.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BookmarkMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookmarkMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Bookmark entity.
// If the Bookmark object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookmarkMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookmarkMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *BookmarkMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *BookmarkMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *BookmarkMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *BookmarkMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BookmarkMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *BookmarkMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetBookID sets the "book" edge to the Book entity by id.
func (m *BookmarkMutation) SetBookID(id uuid.UUID) {
	m.book = &id
}

// ClearBook clears the "book" edge to the Book entity.
func (m *BookmarkMutation) ClearBook() {
	m.clearedbook = true
}

// BookCleared reports if the "book" edge to the Book entity was cleared.
func (m *BookmarkMutation) BookCleared() bool {
	return m.clearedbook
}

// BookID returns the "book" edge ID in the mutation.
func (m *BookmarkMutation) BookID() (id uuid.UUID, exists bool) {
	if m.book != nil {
		return *m.book, true
	}
	return
}

// BookIDs returns the "book" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookID instead. It exists only for internal usage by the builders.
func (m *BookmarkMutation) BookIDs() (ids []uuid.UUID) {
	if id := m.book; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBook resets all changes to the "book" edge.
func (m *BookmarkMutation) ResetBook() {
	m.book = nil
	m.clearedbook = false
}

// Where appends a list predicates to the BookmarkMutation builder.
func (m *BookmarkMutation) Where(ps ...predicate.Bookmark) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookmarkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookmarkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Bookmark, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookmarkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookmarkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Bookmark).
func (m *BookmarkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookmarkMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, bookmark.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookmarkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bookmark.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookmarkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bookmark.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Bookmark field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookmarkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bookmark.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Bookmark field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookmarkMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookmarkMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookmarkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bookmark numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookmarkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookmarkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookmarkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bookmark nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookmarkMutation) ResetField(name string) error {
	switch name {
	case bookmark.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Bookmark field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookmarkMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, bookmark.EdgeOwner)
	}
	if m.book != nil {
		edges = append(edges, bookmark.EdgeBook)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookmarkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bookmark.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case bookmark.EdgeBook:
		if id := m.book; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookmarkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookmarkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookmarkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, bookmark.EdgeOwner)
	}
	if m.clearedbook {
		edges = append(edges, bookmark.EdgeBook)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookmarkMutation) EdgeCleared(name string) bool {
	switch name {
	case bookmark.EdgeOwner:
		return m.clearedowner
	case bookmark.EdgeBook:
		return m.clearedbook
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookmarkMutation) ClearEdge(name string) error {
	switch name {
	case bookmark.EdgeOwner:
		m.ClearOwner()
		return nil
	case bookmark.EdgeBook:
		m.ClearBook()
		return nil
	}
	return fmt.Errorf("unknown Bookmark unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookmarkMutation) ResetEdge(name string) error {
	switch name {
	case bookmark.EdgeOwner:
		m.ResetOwner()
		return nil
	case bookmark.EdgeBook:
		m.ResetBook()
		return nil
	}
	return fmt.Errorf("unknown Bookmark edge %s", name)
}

// ReadingReminderMutation represents an operation that mutates the ReadingReminder nodes in the graph.
type ReadingReminderMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	reminder_time *string
	day_of_week   *readingreminder.DayOfWeek
	is_enabled    *bool
	message       *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*ReadingReminder, error)
	predicates    []predicate.ReadingReminder
}

var _ ent.Mutation = (*ReadingReminderMutation)(nil)

// readingreminderOption allows management of the mutation configuration using functional options.
type readingreminderOption func(*ReadingReminderMutation)

// newReadingReminderMutation creates new mutation for the ReadingReminder entity.
func newReadingReminderMutation(c config, op Op, opts ...readingreminderOption) *ReadingReminderMutation {
	m := &ReadingReminderMutation{
		config:        c,
		op:            op,
		typ:           TypeReadingReminder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReadingReminderID sets the ID field of the mutation.
func withReadingReminderID(id uuid.UUID) readingreminderOption {
	return func(m *ReadingReminderMutation) {
		var (
			err   error
			once  sync.Once
			value *ReadingReminder
		)
		m.oldValue = func(ctx context.Context) (*ReadingReminder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReadingReminder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReadingReminder sets the old ReadingReminder of the mutation.
func withReadingReminder(node *ReadingReminder) readingreminderOption {
	return func(m *ReadingReminderMutation) {
		m.oldValue = func(context.Context) (*ReadingReminder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReadingReminderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReadingReminderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReadingReminder entities.
func (m *ReadingReminderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReadingReminderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReadingReminderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReadingReminder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReminderTime sets the "reminder_time" field.
func (m *ReadingReminderMutation) SetReminderTime(s string) {
	m.reminder_time = &s
}

// ReminderTime returns the value of the "reminder_time" field in the mutation.
func (m *ReadingReminderMutation) ReminderTime() (r string, exists bool) {
	v := m.reminder_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReminderTime returns the old "reminder_time" field's value of the ReadingReminder entity.
// If the ReadingReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReadingReminderMutation) OldReminderTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReminderTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReminderTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReminderTime: %w", err)
	}
	return oldValue.ReminderTime, nil
}

// ResetReminderTime resets all changes to the "reminder_time" field.
func (m *ReadingReminderMutation) ResetReminderTime() {
	m.reminder_time = nil
}

// SetDayOfWeek sets the "day_of_week" field.
func (m *ReadingReminderMutation) SetDayOfWeek(row readingreminder.DayOfWeek) {
	m.day_of_week = &row
}

// DayOfWeek returns the value of the "day_of_week" field in the mutation.
func (m *ReadingReminderMutation) DayOfWeek() (r readingreminder.DayOfWeek, exists bool) {
	v := m.day_of_week
	if v == nil {
		return
	}
	return *v, true
}

// OldDayOfWeek returns the old "day_of_week" field's value of the ReadingReminder entity.
// If the ReadingReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReadingReminderMutation) OldDayOfWeek(ctx context.Context) (v readingreminder.DayOfWeek, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayOfWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayOfWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayOfWeek: %w", err)
	}
	return oldValue.DayOfWeek, nil
}

// ResetDayOfWeek resets all changes to the "day_of_week" field.
func (m *ReadingReminderMutation) ResetDayOfWeek() {
	m.day_of_week = nil
}

// SetIsEnabled sets the "is_enabled" field.
func (m *ReadingReminderMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *ReadingReminderMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the ReadingReminder entity.
// If the ReadingReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReadingReminderMutation) OldIsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *ReadingReminderMutation) ResetIsEnabled() {
	m.is_enabled = nil
}

// SetMessage sets the "message" field.
func (m *ReadingReminderMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ReadingReminderMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the ReadingReminder entity.
// If the ReadingReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReadingReminderMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ReadingReminderMutation) ResetMessage() {
	m.message = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReadingReminderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReadingReminderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReadingReminder entity.
// If the ReadingReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReadingReminderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReadingReminderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReadingReminderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReadingReminderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ReadingReminder entity.
// If the ReadingReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReadingReminderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReadingReminderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ReadingReminderMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ReadingReminderMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ReadingReminderMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ReadingReminderMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ReadingReminderMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ReadingReminderMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the ReadingReminderMutation builder.
func (m *ReadingReminderMutation) Where(ps ...predicate.ReadingReminder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReadingReminderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReadingReminderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReadingReminder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReadingReminderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReadingReminderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReadingReminder).
func (m *ReadingReminderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReadingReminderMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.reminder_time != nil {
		fields = append(fields, readingreminder.FieldReminderTime)
	}
	if m.day_of_week != nil {
		fields = append(fields, readingreminder.FieldDayOfWeek)
	}
	if m.is_enabled != nil {
		fields = append(fields, readingreminder.FieldIsEnabled)
	}
	if m.message != nil {
		fields = append(fields, readingreminder.FieldMessage)
	}
	if m.created_at != nil {
		fields = append(fields, readingreminder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, readingreminder.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReadingReminderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case readingreminder.FieldReminderTime:
		return m.ReminderTime()
	case readingreminder.FieldDayOfWeek:
		return m.DayOfWeek()
	case readingreminder.FieldIsEnabled:
		return m.IsEnabled()
	case readingreminder.FieldMessage:
		return m.Message()
	case readingreminder.FieldCreatedAt:
		return m.CreatedAt()
	case readingreminder.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReadingReminderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case readingreminder.FieldReminderTime:
		return m.OldReminderTime(ctx)
	case readingreminder.FieldDayOfWeek:
		return m.OldDayOfWeek(ctx)
	case readingreminder.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	case readingreminder.FieldMessage:
		return m.OldMessage(ctx)
	case readingreminder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case readingreminder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ReadingReminder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReadingReminderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case readingreminder.FieldReminderTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReminderTime(v)
		return nil
	case readingreminder.FieldDayOfWeek:
		v, ok := value.(readingreminder.DayOfWeek)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayOfWeek(v)
		return nil
	case readingreminder.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	case readingreminder.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case readingreminder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case readingreminder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ReadingReminder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReadingReminderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReadingReminderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReadingReminderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReadingReminder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReadingReminderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReadingReminderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReadingReminderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReadingReminder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReadingReminderMutation) ResetField(name string) error {
	switch name {
	case readingreminder.FieldReminderTime:
		m.ResetReminderTime()
		return nil
	case readingreminder.FieldDayOfWeek:
		m.ResetDayOfWeek()
		return nil
	case readingreminder.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	case readingreminder.FieldMessage:
		m.ResetMessage()
		return nil
	case readingreminder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case readingreminder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ReadingReminder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReadingReminderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, readingreminder.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReadingReminderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case readingreminder.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReadingReminderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReadingReminderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReadingReminderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, readingreminder.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReadingReminderMutation) EdgeCleared(name string) bool {
	switch name {
	case readingreminder.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReadingReminderMutation) ClearEdge(name string) error {
	switch name {
	case readingreminder.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown ReadingReminder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReadingReminderMutation) ResetEdge(name string) error {
	switch name {
	case readingreminder.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown ReadingReminder edge %s", name)
}

// ReviewMutation represents an operation that mutates the Review nodes in the graph.
type ReviewMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	content       *string
	rating        *int
	addrating     *int
	is_public     *bool
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
	book          *uuid.UUID
	clearedbook   bool
	done          bool
	oldValue      func(context.Context) (*Review, error)
	predicates    []predicate.Review
}

var _ ent.Mutation = (*ReviewMutation)(nil)

// reviewOption allows management of the mutation configuration using functional options.
type reviewOption func(*ReviewMutation)

// newReviewMutation creates new mutation for the Review entity.
func newReviewMutation(c config, op Op, opts ...reviewOption) *ReviewMutation {
	m := &ReviewMutation{
		config:        c,
		op:            op,
		typ:           TypeReview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReviewID sets the ID field of the mutation.
func withReviewID(id uuid.UUID) reviewOption {
	return func(m *ReviewMutation) {
		var (
			err   error
			once  sync.Once
			value *Review
		)
		m.oldValue = func(ctx context.Context) (*Review, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Review.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReview sets the old Review of the mutation.
func withReview(node *Review) reviewOption {
	return func(m *ReviewMutation) {
		m.oldValue = func(context.Context) (*Review, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Review entities.
func (m *ReviewMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReviewMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReviewMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Review.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetContent sets the "content" field.
func (m *ReviewMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ReviewMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ReviewMutation) ResetContent() {
	m.content = nil
}

// SetRating sets the "rating" field.
func (m *ReviewMutation) SetRating(i int) {
	m.rating = &i
	m.addrating = nil
}

// Rating returns the value of the "rating" field in the mutation.
func (m *ReviewMutation) Rating() (r int, exists bool) {
	v := m.rating
	if v == nil {
		return
	}
	return *v, true
}

// OldRating returns the old "rating" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldRating(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRating: %w", err)
	}
	return oldValue.Rating, nil
}

// AddRating adds i to the "rating" field.
func (m *ReviewMutation) AddRating(i int) {
	if m.addrating != nil {
		*m.addrating += i
	} else {
		m.addrating = &i
	}
}

// AddedRating returns the value that was added to the "rating" field in this mutation.
func (m *ReviewMutation) AddedRating() (r int, exists bool) {
	v := m.addrating
	if v == nil {
		return
	}
	return *v, true
}

// ResetRating resets all changes to the "rating" field.
func (m *ReviewMutation) ResetRating() {
	m.rating = nil
	m.addrating = nil
}

// SetIsPublic sets the "is_public" field.
func (m *ReviewMutation) SetIsPublic(b bool) {
	m.is_public = &b
}

// IsPublic returns the value of the "is_public" field in the mutation.
func (m *ReviewMutation) IsPublic() (r bool, exists bool) {
	v := m.is_public
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublic returns the old "is_public" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldIsPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublic: %w", err)
	}
	return oldValue.IsPublic, nil
}

// ResetIsPublic resets all changes to the "is_public" field.
func (m *ReviewMutation) ResetIsPublic() {
	m.is_public = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReviewMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReviewMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReviewMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReviewMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReviewMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Review entity.
// If the Review object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReviewMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReviewMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ReviewMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ReviewMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ReviewMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ReviewMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ReviewMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetBookID sets the "book" edge to the Book entity by id.
func (m *ReviewMutation) SetBookID(id uuid.UUID) {
	m.book = &id
}

// ClearBook clears the "book" edge to the Book entity.
func (m *ReviewMutation) ClearBook() {
	m.clearedbook = true
}

// BookCleared reports if the "book" edge to the Book entity was cleared.
func (m *ReviewMutation) BookCleared() bool {
	return m.clearedbook
}

// BookID returns the "book" edge ID in the mutation.
func (m *ReviewMutation) BookID() (id uuid.UUID, exists bool) {
	if m.book != nil {
		return *m.book, true
	}
	return
}

// BookIDs returns the "book" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BookID instead. It exists only for internal usage by the builders.
func (m *ReviewMutation) BookIDs() (ids []uuid.UUID) {
	if id := m.book; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBook resets all changes to the "book" edge.
func (m *ReviewMutation) ResetBook() {
	m.book = nil
	m.clearedbook = false
}

// Where appends a list predicates to the ReviewMutation builder.
func (m *ReviewMutation) Where(ps ...predicate.Review) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReviewMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReviewMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Review, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReviewMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReviewMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Review).
func (m *ReviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReviewMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.content != nil {
		fields = append(fields, review.FieldContent)
	}
	if m.rating != nil {
		fields = append(fields, review.FieldRating)
	}
	if m.is_public != nil {
		fields = append(fields, review.FieldIsPublic)
	}
	if m.created_at != nil {
		fields = append(fields, review.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, review.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case review.FieldContent:
		return m.Content()
	case review.FieldRating:
		return m.Rating()
	case review.FieldIsPublic:
		return m.IsPublic()
	case review.FieldCreatedAt:
		return m.CreatedAt()
	case review.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case review.FieldContent:
		return m.OldContent(ctx)
	case review.FieldRating:
		return m.OldRating(ctx)
	case review.FieldIsPublic:
		return m.OldIsPublic(ctx)
	case review.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case review.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Review field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case review.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case review.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRating(v)
		return nil
	case review.FieldIsPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublic(v)
		return nil
	case review.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case review.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReviewMutation) AddedFields() []string {
	var fields []string
	if m.addrating != nil {
		fields = append(fields, review.FieldRating)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case review.FieldRating:
		return m.AddedRating()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case review.FieldRating:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRating(v)
		return nil
	}
	return fmt.Errorf("unknown Review numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Review nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReviewMutation) ResetField(name string) error {
	switch name {
	case review.FieldContent:
		m.ResetContent()
		return nil
	case review.FieldRating:
		m.ResetRating()
		return nil
	case review.FieldIsPublic:
		m.ResetIsPublic()
		return nil
	case review.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case review.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Review field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, review.EdgeOwner)
	}
	if m.book != nil {
		edges = append(edges, review.EdgeBook)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case review.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case review.EdgeBook:
		if id := m.book; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReviewMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, review.EdgeOwner)
	}
	if m.clearedbook {
		edges = append(edges, review.EdgeBook)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReviewMutation) EdgeCleared(name string) bool {
	switch name {
	case review.EdgeOwner:
		return m.clearedowner
	case review.EdgeBook:
		return m.clearedbook
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReviewMutation) ClearEdge(name string) error {
	switch name {
	case review.EdgeOwner:
		m.ClearOwner()
		return nil
	case review.EdgeBook:
		m.ClearBook()
		return nil
	}
	return fmt.Errorf("unknown Review unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReviewMutation) ResetEdge(name string) error {
	switch name {
	case review.EdgeOwner:
		m.ResetOwner()
		return nil
	case review.EdgeBook:
		m.ResetBook()
		return nil
	}
	return fmt.Errorf("unknown Review edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	nick_name                *string
	email                    *string
	password                 *string
	is_published             *bool
	is_terms_agreed          *bool
	fcm_token                *string
	timezone                 *string
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	books                    map[uuid.UUID]struct{}
	removedbooks             map[uuid.UUID]struct{}
	clearedbooks             bool
	reviews                  map[uuid.UUID]struct{}
	removedreviews           map[uuid.UUID]struct{}
	clearedreviews           bool
	bookmarks                map[uuid.UUID]struct{}
	removedbookmarks         map[uuid.UUID]struct{}
	clearedbookmarks         bool
	reading_reminders        map[uuid.UUID]struct{}
	removedreading_reminders map[uuid.UUID]struct{}
	clearedreading_reminders bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNickName sets the "nick_name" field.
func (m *UserMutation) SetNickName(s string) {
	m.nick_name = &s
}

// NickName returns the value of the "nick_name" field in the mutation.
func (m *UserMutation) NickName() (r string, exists bool) {
	v := m.nick_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old "nick_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ResetNickName resets all changes to the "nick_name" field.
func (m *UserMutation) ResetNickName() {
	m.nick_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetIsPublished sets the "is_published" field.
func (m *UserMutation) SetIsPublished(b bool) {
	m.is_published = &b
}

// IsPublished returns the value of the "is_published" field in the mutation.
func (m *UserMutation) IsPublished() (r bool, exists bool) {
	v := m.is_published
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPublished returns the old "is_published" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsPublished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPublished: %w", err)
	}
	return oldValue.IsPublished, nil
}

// ResetIsPublished resets all changes to the "is_published" field.
func (m *UserMutation) ResetIsPublished() {
	m.is_published = nil
}

// SetIsTermsAgreed sets the "is_terms_agreed" field.
func (m *UserMutation) SetIsTermsAgreed(b bool) {
	m.is_terms_agreed = &b
}

// IsTermsAgreed returns the value of the "is_terms_agreed" field in the mutation.
func (m *UserMutation) IsTermsAgreed() (r bool, exists bool) {
	v := m.is_terms_agreed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTermsAgreed returns the old "is_terms_agreed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsTermsAgreed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTermsAgreed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTermsAgreed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTermsAgreed: %w", err)
	}
	return oldValue.IsTermsAgreed, nil
}

// ResetIsTermsAgreed resets all changes to the "is_terms_agreed" field.
func (m *UserMutation) ResetIsTermsAgreed() {
	m.is_terms_agreed = nil
}

// SetFcmToken sets the "fcm_token" field.
func (m *UserMutation) SetFcmToken(s string) {
	m.fcm_token = &s
}

// FcmToken returns the value of the "fcm_token" field in the mutation.
func (m *UserMutation) FcmToken() (r string, exists bool) {
	v := m.fcm_token
	if v == nil {
		return
	}
	return *v, true
}

// OldFcmToken returns the old "fcm_token" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFcmToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFcmToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFcmToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFcmToken: %w", err)
	}
	return oldValue.FcmToken, nil
}

// ClearFcmToken clears the value of the "fcm_token" field.
func (m *UserMutation) ClearFcmToken() {
	m.fcm_token = nil
	m.clearedFields[user.FieldFcmToken] = struct{}{}
}

// FcmTokenCleared returns if the "fcm_token" field was cleared in this mutation.
func (m *UserMutation) FcmTokenCleared() bool {
	_, ok := m.clearedFields[user.FieldFcmToken]
	return ok
}

// ResetFcmToken resets all changes to the "fcm_token" field.
func (m *UserMutation) ResetFcmToken() {
	m.fcm_token = nil
	delete(m.clearedFields, user.FieldFcmToken)
}

// SetTimezone sets the "timezone" field.
func (m *UserMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserMutation) ResetTimezone() {
	m.timezone = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddBookIDs adds the "books" edge to the Book entity by ids.
func (m *UserMutation) AddBookIDs(ids ...uuid.UUID) {
	if m.books == nil {
		m.books = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.books[ids[i]] = struct{}{}
	}
}

// ClearBooks clears the "books" edge to the Book entity.
func (m *UserMutation) ClearBooks() {
	m.clearedbooks = true
}

// BooksCleared reports if the "books" edge to the Book entity was cleared.
func (m *UserMutation) BooksCleared() bool {
	return m.clearedbooks
}

// RemoveBookIDs removes the "books" edge to the Book entity by IDs.
func (m *UserMutation) RemoveBookIDs(ids ...uuid.UUID) {
	if m.removedbooks == nil {
		m.removedbooks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.books, ids[i])
		m.removedbooks[ids[i]] = struct{}{}
	}
}

// RemovedBooks returns the removed IDs of the "books" edge to the Book entity.
func (m *UserMutation) RemovedBooksIDs() (ids []uuid.UUID) {
	for id := range m.removedbooks {
		ids = append(ids, id)
	}
	return
}

// BooksIDs returns the "books" edge IDs in the mutation.
func (m *UserMutation) BooksIDs() (ids []uuid.UUID) {
	for id := range m.books {
		ids = append(ids, id)
	}
	return
}

// ResetBooks resets all changes to the "books" edge.
func (m *UserMutation) ResetBooks() {
	m.books = nil
	m.clearedbooks = false
	m.removedbooks = nil
}

// AddReviewIDs adds the "reviews" edge to the Review entity by ids.
func (m *UserMutation) AddReviewIDs(ids ...uuid.UUID) {
	if m.reviews == nil {
		m.reviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reviews[ids[i]] = struct{}{}
	}
}

// ClearReviews clears the "reviews" edge to the Review entity.
func (m *UserMutation) ClearReviews() {
	m.clearedreviews = true
}

// ReviewsCleared reports if the "reviews" edge to the Review entity was cleared.
func (m *UserMutation) ReviewsCleared() bool {
	return m.clearedreviews
}

// RemoveReviewIDs removes the "reviews" edge to the Review entity by IDs.
func (m *UserMutation) RemoveReviewIDs(ids ...uuid.UUID) {
	if m.removedreviews == nil {
		m.removedreviews = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reviews, ids[i])
		m.removedreviews[ids[i]] = struct{}{}
	}
}

// RemovedReviews returns the removed IDs of the "reviews" edge to the Review entity.
func (m *UserMutation) RemovedReviewsIDs() (ids []uuid.UUID) {
	for id := range m.removedreviews {
		ids = append(ids, id)
	}
	return
}

// ReviewsIDs returns the "reviews" edge IDs in the mutation.
func (m *UserMutation) ReviewsIDs() (ids []uuid.UUID) {
	for id := range m.reviews {
		ids = append(ids, id)
	}
	return
}

// ResetReviews resets all changes to the "reviews" edge.
func (m *UserMutation) ResetReviews() {
	m.reviews = nil
	m.clearedreviews = false
	m.removedreviews = nil
}

// AddBookmarkIDs adds the "bookmarks" edge to the Bookmark entity by ids.
func (m *UserMutation) AddBookmarkIDs(ids ...uuid.UUID) {
	if m.bookmarks == nil {
		m.bookmarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.bookmarks[ids[i]] = struct{}{}
	}
}

// ClearBookmarks clears the "bookmarks" edge to the Bookmark entity.
func (m *UserMutation) ClearBookmarks() {
	m.clearedbookmarks = true
}

// BookmarksCleared reports if the "bookmarks" edge to the Bookmark entity was cleared.
func (m *UserMutation) BookmarksCleared() bool {
	return m.clearedbookmarks
}

// RemoveBookmarkIDs removes the "bookmarks" edge to the Bookmark entity by IDs.
func (m *UserMutation) RemoveBookmarkIDs(ids ...uuid.UUID) {
	if m.removedbookmarks == nil {
		m.removedbookmarks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.bookmarks, ids[i])
		m.removedbookmarks[ids[i]] = struct{}{}
	}
}

// RemovedBookmarks returns the removed IDs of the "bookmarks" edge to the Bookmark entity.
func (m *UserMutation) RemovedBookmarksIDs() (ids []uuid.UUID) {
	for id := range m.removedbookmarks {
		ids = append(ids, id)
	}
	return
}

// BookmarksIDs returns the "bookmarks" edge IDs in the mutation.
func (m *UserMutation) BookmarksIDs() (ids []uuid.UUID) {
	for id := range m.bookmarks {
		ids = append(ids, id)
	}
	return
}

// ResetBookmarks resets all changes to the "bookmarks" edge.
func (m *UserMutation) ResetBookmarks() {
	m.bookmarks = nil
	m.clearedbookmarks = false
	m.removedbookmarks = nil
}

// AddReadingReminderIDs adds the "reading_reminders" edge to the ReadingReminder entity by ids.
func (m *UserMutation) AddReadingReminderIDs(ids ...uuid.UUID) {
	if m.reading_reminders == nil {
		m.reading_reminders = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reading_reminders[ids[i]] = struct{}{}
	}
}

// ClearReadingReminders clears the "reading_reminders" edge to the ReadingReminder entity.
func (m *UserMutation) ClearReadingReminders() {
	m.clearedreading_reminders = true
}

// ReadingRemindersCleared reports if the "reading_reminders" edge to the ReadingReminder entity was cleared.
func (m *UserMutation) ReadingRemindersCleared() bool {
	return m.clearedreading_reminders
}

// RemoveReadingReminderIDs removes the "reading_reminders" edge to the ReadingReminder entity by IDs.
func (m *UserMutation) RemoveReadingReminderIDs(ids ...uuid.UUID) {
	if m.removedreading_reminders == nil {
		m.removedreading_reminders = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reading_reminders, ids[i])
		m.removedreading_reminders[ids[i]] = struct{}{}
	}
}

// RemovedReadingReminders returns the removed IDs of the "reading_reminders" edge to the ReadingReminder entity.
func (m *UserMutation) RemovedReadingRemindersIDs() (ids []uuid.UUID) {
	for id := range m.removedreading_reminders {
		ids = append(ids, id)
	}
	return
}

// ReadingRemindersIDs returns the "reading_reminders" edge IDs in the mutation.
func (m *UserMutation) ReadingRemindersIDs() (ids []uuid.UUID) {
	for id := range m.reading_reminders {
		ids = append(ids, id)
	}
	return
}

// ResetReadingReminders resets all changes to the "reading_reminders" edge.
func (m *UserMutation) ResetReadingReminders() {
	m.reading_reminders = nil
	m.clearedreading_reminders = false
	m.removedreading_reminders = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.nick_name != nil {
		fields = append(fields, user.FieldNickName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.is_published != nil {
		fields = append(fields, user.FieldIsPublished)
	}
	if m.is_terms_agreed != nil {
		fields = append(fields, user.FieldIsTermsAgreed)
	}
	if m.fcm_token != nil {
		fields = append(fields, user.FieldFcmToken)
	}
	if m.timezone != nil {
		fields = append(fields, user.FieldTimezone)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldNickName:
		return m.NickName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldIsPublished:
		return m.IsPublished()
	case user.FieldIsTermsAgreed:
		return m.IsTermsAgreed()
	case user.FieldFcmToken:
		return m.FcmToken()
	case user.FieldTimezone:
		return m.Timezone()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldNickName:
		return m.OldNickName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldIsPublished:
		return m.OldIsPublished(ctx)
	case user.FieldIsTermsAgreed:
		return m.OldIsTermsAgreed(ctx)
	case user.FieldFcmToken:
		return m.OldFcmToken(ctx)
	case user.FieldTimezone:
		return m.OldTimezone(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldIsPublished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPublished(v)
		return nil
	case user.FieldIsTermsAgreed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTermsAgreed(v)
		return nil
	case user.FieldFcmToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFcmToken(v)
		return nil
	case user.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldFcmToken) {
		fields = append(fields, user.FieldFcmToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldFcmToken:
		m.ClearFcmToken()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldNickName:
		m.ResetNickName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldIsPublished:
		m.ResetIsPublished()
		return nil
	case user.FieldIsTermsAgreed:
		m.ResetIsTermsAgreed()
		return nil
	case user.FieldFcmToken:
		m.ResetFcmToken()
		return nil
	case user.FieldTimezone:
		m.ResetTimezone()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.books != nil {
		edges = append(edges, user.EdgeBooks)
	}
	if m.reviews != nil {
		edges = append(edges, user.EdgeReviews)
	}
	if m.bookmarks != nil {
		edges = append(edges, user.EdgeBookmarks)
	}
	if m.reading_reminders != nil {
		edges = append(edges, user.EdgeReadingReminders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.books))
		for id := range m.books {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.reviews))
		for id := range m.reviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBookmarks:
		ids := make([]ent.Value, 0, len(m.bookmarks))
		for id := range m.bookmarks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReadingReminders:
		ids := make([]ent.Value, 0, len(m.reading_reminders))
		for id := range m.reading_reminders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbooks != nil {
		edges = append(edges, user.EdgeBooks)
	}
	if m.removedreviews != nil {
		edges = append(edges, user.EdgeReviews)
	}
	if m.removedbookmarks != nil {
		edges = append(edges, user.EdgeBookmarks)
	}
	if m.removedreading_reminders != nil {
		edges = append(edges, user.EdgeReadingReminders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBooks:
		ids := make([]ent.Value, 0, len(m.removedbooks))
		for id := range m.removedbooks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReviews:
		ids := make([]ent.Value, 0, len(m.removedreviews))
		for id := range m.removedreviews {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeBookmarks:
		ids := make([]ent.Value, 0, len(m.removedbookmarks))
		for id := range m.removedbookmarks {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReadingReminders:
		ids := make([]ent.Value, 0, len(m.removedreading_reminders))
		for id := range m.removedreading_reminders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbooks {
		edges = append(edges, user.EdgeBooks)
	}
	if m.clearedreviews {
		edges = append(edges, user.EdgeReviews)
	}
	if m.clearedbookmarks {
		edges = append(edges, user.EdgeBookmarks)
	}
	if m.clearedreading_reminders {
		edges = append(edges, user.EdgeReadingReminders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBooks:
		return m.clearedbooks
	case user.EdgeReviews:
		return m.clearedreviews
	case user.EdgeBookmarks:
		return m.clearedbookmarks
	case user.EdgeReadingReminders:
		return m.clearedreading_reminders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBooks:
		m.ResetBooks()
		return nil
	case user.EdgeReviews:
		m.ResetReviews()
		return nil
	case user.EdgeBookmarks:
		m.ResetBookmarks()
		return nil
	case user.EdgeReadingReminders:
		m.ResetReadingReminders()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
