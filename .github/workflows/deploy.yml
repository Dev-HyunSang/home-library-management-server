name: Deploy to Azure VM

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ${{ secrets.ACR_LOGIN_SERVER }}
  IMAGE_NAME: home-library-server

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Get Public IP
        id: ip
        uses: haythem/public-ip@v1.3

      - name: Print Public IP
        run: |
          echo ${{ steps.ip.outputs.ipv4 }}

      - name: Login to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and push Docker image
        run: |
          docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} .
          docker build -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest .
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Create .env file on VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          port: ${{ secrets.VM_PORT }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          script: |
            mkdir -p /home/${{ secrets.VM_USERNAME }}/app
            cat > /home/${{ secrets.VM_USERNAME }}/app/.env.prod << 'EOF'
            # MYSQL
            MYSQL_DRIVER=mysql
            MYSQL_HOST=${{ secrets.MYSQL_HOST }}
            MYSQL_PORT=3306
            MYSQL_USER=${{ secrets.MYSQL_USER }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            MYSQL_DBNAME=${{ secrets.MYSQL_DBNAME }}
            MYSQL_SSLMODE=${{ secrets.MYSQL_SSLMODE }}

            # REDIS
            REDIS_HOST=${{ secrets.REDIS_HOST }}
            REDIS_PORT=6379
            REDIS_USERNAME=${{ secrets.REDIS_USERNAME }}
            REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
            REDIS_DB=0

            # COOKIE
            AUTH_COOKIE_KEY=${{ secrets.AUTH_COOKIE_KEY }}

            # JWT
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            JWT_TTL=${{ secrets.JWT_TTL }}

            # KAFKA
            KAFKA_BROKERS=kafka:9092
            KAFKA_TOPIC=notifications
            KAFKA_GROUP_ID=home-library-notification-group

            # NAVER BOOK API
            NAVER_API_CLIENT_ID=${{ secrets.NAVER_API_CLIENT_ID }}
            NAVER_API_CLIENT_SECRET=${{ secrets.NAVER_API_CLIENT_SECRET }}

            # GOOGLE MAIL API
            GOOGLE_MAIL_ADDRESS=${{ secrets.GOOGLE_MAIL_ADDRESS }}
            GOOGLE_MAIL_PASSWORD=${{ secrets.GOOGLE_MAIL_PASSWORD }}
            GOOGLE_MAIL_SMTP=${{ secrets.GOOGLE_MAIL_SMTP }}

            # FCM
            FCM_SERVICE_ACCOUNT_PATH=${{ secrets.FCM_SERVICE_ACCOUNT_PATH }}

            # ADMIN
            ADMIN_BOOTSTRAP_KEY=${{ secrets.ADMIN_BOOTSTRAP_KEY }}

            # APP
            APP_PORT=3000
            APP_DEBUG=false
            APP_ENV=production
            EOF

      - name: Backup SSL certs and clean nginx on VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          port: ${{ secrets.VM_PORT }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          script: |
            cd /home/${{ secrets.VM_USERNAME }}/app
            # Backup SSL certs if they exist
            if [ -d nginx/ssl ] && [ "$(ls -A nginx/ssl 2>/dev/null)" ]; then
              mkdir -p /tmp/nginx-ssl-backup
              sudo cp -r nginx/ssl/* /tmp/nginx-ssl-backup/
              sudo chown -R $USER:$USER /tmp/nginx-ssl-backup
            fi
            # Remove entire nginx directory (may be owned by root from docker)
            sudo rm -rf nginx

      - name: Copy docker-compose and nginx files to VM
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VM_HOST }}
          port: ${{ secrets.VM_PORT }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          source: "docker-compose.yml,docker-compose.prod.yml,nginx"
          target: "/home/${{ secrets.VM_USERNAME }}/app"

      - name: Restore SSL certs on VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          port: ${{ secrets.VM_PORT }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          script: |
            cd /home/${{ secrets.VM_USERNAME }}/app
            if [ -d /tmp/nginx-ssl-backup ] && [ "$(ls -A /tmp/nginx-ssl-backup 2>/dev/null)" ]; then
              mkdir -p nginx/ssl
              cp -r /tmp/nginx-ssl-backup/* nginx/ssl/
              rm -rf /tmp/nginx-ssl-backup
            fi

      - name: Generate SSL certificate if not exists
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          port: ${{ secrets.VM_PORT }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          script: |
            cd /home/${{ secrets.VM_USERNAME }}/app
            if [ ! -f nginx/ssl/fullchain.pem ]; then
              chmod +x nginx/generate-ssl.sh
              ./nginx/generate-ssl.sh
            fi

      - name: Deploy all services
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          port: ${{ secrets.VM_PORT }}
          username: ${{ secrets.VM_USERNAME }}
          key: ${{ secrets.VM_SSH_KEY }}
          script: |
            cd /home/${{ secrets.VM_USERNAME }}/app

            # Login to ACR
            docker login ${{ secrets.ACR_LOGIN_SERVER }} -u ${{ secrets.ACR_USERNAME }} -p ${{ secrets.ACR_PASSWORD }}

            # Pull latest application image
            docker pull ${{ secrets.ACR_LOGIN_SERVER }}/home-library-server:latest

            # Stop existing services
            docker compose -f docker-compose.yml -f docker-compose.prod.yml down

            # Start all services with .env.prod file
            docker compose -f docker-compose.yml -f docker-compose.prod.yml --env-file .env.prod up -d

            # Cleanup old images
            docker image prune -f
